{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"tslib\"","webpack:///./src/injector.ts","webpack:///./src/singleton.ts","webpack:///./src/reflect.ts","webpack:///./src/index.ts","webpack:///./src/inject.ts","webpack:///./src/constants.ts","webpack:///(webpack)/buildin/global.js","webpack:///external \"reflect-metadata\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,kC;;;;;;;;;;ACAA,2CAAwC;AASxC,MAAM,YAAY,GAAG,IAAI,GAAG,EAA0B,CAAC;AA8BvD,MAAa,QAAQ;IAEjB;;;;;;;;;;OAUG;IACI,MAAM,CAAC,QAAQ,CAAC,IAAkB,EAAE,KAAU,EAAE,OAA0B;QAC7E,MAAM,UAAU,GAAG,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC9D,MAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;QACnD,IAAI,CAAC,KAAK,EAAE;YAAE,MAAM,IAAI,SAAS,CAAC,mCAAmC,UAAU,GAAG,CAAC,CAAC;SAAE;QACtF,MAAM,OAAO,GAAG,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC;QAClE,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAChC,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,KAAK,EAAE;YAChB,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SAC5C;QACD,qBAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACtB,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED;;;;;;;;;;OAUG;IACI,MAAM,CAAC,aAAa,CAAC,IAAkB,EAAE,KAA+B,EAAE,OAA0B;QACvG,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAG,IAAS,EAAE,EAAE,CAAC,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IAC9E,CAAC;IAED;;;;;;;;;;;OAWG;IACI,MAAM,CAAC,GAAG,CAAkC,IAAO,EAAE,OAAuB;QAC/E,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAE;YACnB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SAClC;QACD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACzB,MAAM,IAAI,GAAG,OAAO,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACnE,MAAM,IAAI,KAAK,CAAC,gBAAgB,IAAI,uBAAuB,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,EAAE,CAAC,CAAC;SACjF;QACD,MAAM,OAAO,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC;QACxC,MAAM,IAAI,GAAU,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;QAC/E,IAAI;YACA,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACpC;QAAC,OAAO,CAAC,EAAE;YACR,OAAO,IAAK,OAAe,CAAC,GAAG,IAAI,CAAC,CAAC;SACxC;IACL,CAAC;IAGD;;;;;;;;OAQG;IACI,MAAM,CAAC,YAAY,CAAkC,IAAO,EAAE,YAAgB,EAAE,OAAuB;QAC1G,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACzB,OAAO,YAAmB,CAAC;SAC9B;QACD,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAwB,CAAC;IAC1D,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,eAAe,CAAC,IAAmB;QAC7C,IAAI,IAAI,KAAK,SAAS,EAAE;YACpB,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;SACrE;aAAM,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YAC/B,qBAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACzB;aAAM;YACH,MAAM,IAAI,GAAG,OAAO,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACnE,MAAM,IAAI,KAAK,CAAC,gBAAgB,IAAI,qBAAqB,CAAC,CAAC;SAC9D;IACL,CAAC;CACJ;AArGD,4BAqGC;;;;;;;;;;;AC5ID,MAAM,SAAS,GAAG,MAAM,EAAE,CAAC;AAE3B,SAAgB,SAAS;IACrB,OAAO,UAAU,MAAW;QACxB,OAAO,KAAM,SAAQ,MAAM;YACvB,YAAY,GAAG,IAAS;gBACpB,IAAI,SAAS,IAAI,MAAM,EAAE;oBACrB,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC;iBAC5B;qBAAM;oBACH,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;oBACf,MAAM,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;iBAC5B;YACL,CAAC;SACJ;IACL,CAAC;AACL,CAAC;AAbD,8BAaC;AAED,SAAS,CAAC,KAAK,GAAG,UAAU,MAAW;IACnC,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;QAC9B,IAAI,SAAS,IAAI,MAAM,EAAE;YACrB,GAAG;gBACC,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC;gBACzB,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;aAC1C,QACM,MAAM,IAAI,MAAM,KAAK,MAAM,CAAC,SAAS,EAAC;YAC7C,OAAO,IAAI,CAAC;SACf;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;KACJ;SAAM,IAAI,MAAM,CAAC,WAAW,EAAE;QAC3B,OAAO,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;KAC9C;SAAM;QACH,OAAO,KAAK,CAAC;KAChB;AACL,CAAC;;;;;;;;;;ACjCD,uBAA0B;AAE1B,SAAS,OAAO,CAAC,GAAQ;IACrB,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,CAAC,WAAW,KAAK,UAAU,CAAC;AAC5E,CAAC;AAED,MAAM,OAAO,GAAmB,CAAC;IAC7B,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;QAClB,OAAO,OAAO,CAAC;KAClB;SAAM,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;QAChC,OAAO,MAAM,CAAC,OAAO,CAAC;KACzB;SAAM,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;QACxD,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;KAChC;IACD,OAAO,EAAE,CAAC;AACd,CAAC,EAAE,CAAC,CAAC;AACL,kBAAe,OAAO,CAAC;;;;;;;;;;;;;ACjBvB,wCAAsC;AAA7B,4GAAQ;AACjB,sCAAwD;AAA/C,sGAAM;AAAE,8GAAU;AAAE,0GAAQ;AACrC,yCAAwC;AAA/B,+GAAS;AAClB,+DAAqC;;;;;;;;;;;;ACHrC,2CAA8D;AAC9D,0CAAqF;AACrF,kEAAgC;AAEnB,0BAAkB,GAAG,MAAM,EAAE,CAAC;AAE3C;;;GAGG;AACH,SAAgB,MAAM,CAAC,OAAsC;IACzD,MAAM,GAAG,GAAkB,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAS,CAAC;IACvG,OAAO,UAAU,MAAW,EAAE,IAAY,EAAE,KAAc;QACtD,IAAI,IAAI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,KAAK,KAAK,SAAS,EAAE;YAC7D,aAAa;YACb,IAAI,IAAI,GAAG,iBAAO,CAAC,cAAc,CAAC,uBAAW,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YAC7D,IAAI,GAAG,GAAI,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,GAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC;YAC5D,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,IAAI,gBAAgB,IAAI,aAAa,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YACtF,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,mBAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC;SAC9E;aAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,IAAI,EAAE;YAC3C,wBAAwB;YACxB,IAAI,QAAQ,GAA+B,iBAAO,CAAC,cAAc,CAAC,0BAAkB,EAAE,MAAM,CAAC,CAAC;YAC9F,QAAQ,GAAG,QAAQ,IAAI,IAAI,GAAG,EAAE,CAAC;YACjC,MAAM,SAAS,GAAG,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC;YAC1C,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,IAAI,OAAO,KAAK,kBAAkB,SAAS,cAAc,CAAC;YACjF,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YACzB,iBAAO,CAAC,cAAc,CAAC,0BAAkB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;SAChE;aAAM;YACH,OAAO,CAAC,IAAI,CAAC,0DAA0D,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;SACzG;IACL,CAAC;AACL,CAAC;AArBD,wBAqBC;AAED;;;GAGG;AACH,SAAgB,QAAQ,CAAC,OAAwD;IAC7E,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAClE,CAAC;AAFD,4BAEC;AAED;;GAEG;AACH,SAAgB,UAAU,CAAC,OAA0B;IACjD,OAAO,UAAiD,IAAO;QAC3D,MAAM,QAAQ,GAA+B,iBAAO,CAAC,cAAc,CAAC,0BAAkB,EAAE,IAAI,CAAC,CAAC;QAC9F,MAAM,MAAM,GAAG,KAAM,SAAQ,IAAI;YAC7B,YAAY,GAAG,IAAW;gBACtB,MAAM,UAAU,GAAe,iBAAO,CAAC,cAAc,CAAC,8BAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;gBACtF,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;oBAC5B,MAAM,IAAI,GAAG,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBAC7C,MAAM,IAAI,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC7D,IAAI,CAAC,KAAK,CAAC,KAAK,SAAS,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,mBAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC1E,CAAC,CAAC,CAAC;gBACH,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;YACnB,CAAC;SACJ,CAAC;QACF,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAC5D,mBAAQ,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;QAChD,OAAO,MAAM,CAAC;IAClB,CAAC;AACL,CAAC;AAlBD,gCAkBC;;;;;;;;;;;AC9DY,0BAAkB,GAAG,mBAAmB,CAAC;AACzC,mBAAW,GAAG,aAAa,CAAC;AAC5B,0BAAkB,GAAG,mBAAmB,CAAC;;;;;;;ACFtD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACnBA,6C","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = require(\"tslib\");","import { Singleton } from './singleton';\n\n// tslint:disable-next-line\nexport type RegisterType = Function | symbol | number | string;\n\ntype InjectionType<R, T> = R extends object | Primitive ? R : T extends new (...args: any) => any ? InstanceType<T> : any;\n\ntype Primitive = string | number | symbol | boolean | bigint | undefined | null;\n\nconst INJECT_ITEMS = new Map<RegisterType, Function>();\n\nexport interface InjectionOptions {\n    /**\n     * The another name for current Service\n     */\n    alias?: RegisterType;\n}\n\nexport interface InjectOptions {\n    /**\n     * The parameters required by the factory function.\n     */\n    args?: ArrayLike<any>;\n    /**\n     * The type to register\n     */\n    type?: RegisterType;\n    /**\n     * The injection source for debugging\n     */\n    source?: string;\n    /**\n     * The injected item is optional\n     * @default false\n     */\n    optional?: boolean;\n\n}\n\nexport class Injector {\n\n    /**\n     * Register a service for injection.\n     * @param type The service type to be register.\n     * @param value The associated value can be a factory function.\n     * @param opitons The injection options.\n     *\n     * @example\n     * Injector.register(\"\", \"default value\");\n     * Injector.register(Number, () => Math.random());\n     * Injector.register(IDemo, new Demo());\n     */\n    public static register(type: RegisterType, value: any, options?: InjectionOptions) {\n        const validTypes = ['function', 'number', 'string', 'symbol'];\n        const valid = validTypes.indexOf(typeof type) >= 0;\n        if (!valid) { throw new TypeError(`The 'type' parameter must be in ${validTypes}.`); }\n        const factory = typeof value === \"function\" ? value : () => value;\n        INJECT_ITEMS.set(type, factory);\n        if (options?.alias) {\n            INJECT_ITEMS.set(options.alias, factory);\n        }\n        Singleton.clear(type);\n        return Injector;\n    }\n\n    /**\n     * Register a service for injection.\n     * @param type The service type to be register.\n     * @param value The associated value must be a class.\n     * @param opitons The injection options.\n     *\n     * @example\n     * Injector.register(\"\", \"default value\");\n     * class Demo extens IDemo{}\n     * Injector.register(IDemo, Demo);\n     */\n    public static registerClass(type: RegisterType, value: new(...args: any) => any, options?: InjectionOptions) {\n        return this.register(type, (...args: any) => new value(...args), options);\n    }\n\n    /**\n     * Get the value corresponding to a specific type, the type must be registered in advance.\n     * If the type was't injected in advance and the `optional` options is absent or false, an error will be throw.\n     * @param type The type registered.\n     * @param options The injecttion options.\n     *\n     * @example\n     * class Demo{}\n     * Injector.register(\"demo\", new Demo());\n     * const instance = Injector.get(\"demo\");\n     * const typedInstance = Injector.get<Demo>(\"demo\");\n     */\n    public static get<R, T extends RegisterType = any>(type: T, options?: InjectOptions): InjectionType<R, T> {\n        if (options?.optional) {\n            return this.getOrDefault(type);\n        }\n        if (!INJECT_ITEMS.has(type)) {\n            const name = typeof type === 'function' ? type.name : String(type);\n            throw new Error(`Missing type ${name} injection [source]:${options?.source}`);\n        }\n        const factory = INJECT_ITEMS.get(type)!;\n        const args: any[] = options && Array.isArray(options.args) ? options.args : [];\n        try {\n            return factory.apply(null, args);\n        } catch (e) {\n            return new (factory as any)(...args);\n        }\n    }\n\n\n    /**\n     * Try Get the value corresponding to a specific type\n     * @param type The type registered.\n     * @param defaultValue The value returned by default.\n     * @param options The injecttion options.\n     *\n     * @example\n     * Injector.getOrDefault(ClassType, new ClassType());\n     */\n    public static getOrDefault<R, T extends RegisterType = any>(type: T, defaultValue?: R, options?: InjectOptions): InjectionType<R, T> {\n        if (!INJECT_ITEMS.has(type)) {\n            return defaultValue as any;\n        }\n        return this.get(type, options) as InjectionType<R, T>;\n    }\n\n    /**\n     * Clear singleton of specified type, if type is omitted, clear all singletons of type.\n     * @param type The specified type to clear\n     */\n    public static clearSingletons(type?: RegisterType) {\n        if (type === undefined) {\n            Array.from(INJECT_ITEMS.keys()).forEach(Injector.clearSingletons);\n        } else if (INJECT_ITEMS.has(type)) {\n            Singleton.clear(type);\n        } else {\n            const name = typeof type === 'function' ? type.name : String(type);\n            throw new Error(`Missing type ${name} injection to clear`);\n        }\n    }\n}\n","const SINGLETON = Symbol();\r\n\r\nexport function Singleton() {\r\n    return function (target: any): any {\r\n        return class extends target {\r\n            constructor(...args: any) {\r\n                if (SINGLETON in target) {\r\n                    return target[SINGLETON];\r\n                } else {\r\n                    super(...args);\r\n                    target[SINGLETON] = this;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nSingleton.clear = function (target: any): boolean {\r\n    if (typeof target === 'function') {\r\n        if (SINGLETON in target) {\r\n            do {\r\n                delete target[SINGLETON];\r\n                target = Object.getPrototypeOf(target);\r\n            }\r\n            while (target && target !== Object.prototype)\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (target.constructor) {\r\n        return Singleton.clear(target.constructor);\r\n    } else {\r\n        return false;\r\n    }\r\n}","declare const global: any;\nimport \"reflect-metadata\";\n\nfunction isValid(obj: any) {\n    return typeof obj === \"object\" && typeof obj.getMetadata === \"function\";\n}\n\nconst reflect: typeof Reflect = (function() {\n    if (isValid(Reflect)) {\n        return Reflect;\n    } else if (isValid(global.Reflect)) {\n        return global.Reflect;\n    } else if (isValid(global.global && global.global.Reflect)) {\n        return global.global.Reflect;\n    }\n    return {};\n}());\nexport default reflect;\n","export { Injector } from \"./injector\";\nexport { Inject, Injectable, Optional } from \"./inject\";\nexport { Singleton } from './singleton';\nexport * as Reflect from './reflect';\n","import { DESIGN_TYPE, DESIGN_PARAM_TYPES } from \"./constants\";\nimport { Injector, InjectOptions, RegisterType, InjectionOptions } from \"./injector\";\nimport Reflect from './reflect';\n\nexport const INJECTED_ARGUMENTS = Symbol();\n\n/**\n * Tag arguments or properties to inject.\n * @param options Injection options\n */\nexport function Inject(options?: InjectOptions | RegisterType) {\n    const opt: InjectOptions = options && typeof options === 'object' ? options : { type: options } as any;\n    return function (target: any, name: string, index?: number): void {\n        if (name && typeof target !== 'function' && index === undefined) {\n            // properties\n            let type = Reflect.getOwnMetadata(DESIGN_TYPE, target, name);\n            type = opt!.type !== undefined ? opt!.type : (type || name);\n            opt.source = opt.source || `the property ${name} in class ${target.constructor.name}`;\n            Object.defineProperty(target, name, { get: () => Injector.get(type, opt) })\n        } else if (typeof index === 'number' && !name) {\n            // constructor arguments\n            let metadata: Map<number, InjectOptions> = Reflect.getOwnMetadata(INJECTED_ARGUMENTS, target);\n            metadata = metadata || new Map();\n            const className = target.constructor.name;\n            opt.source = opt.source || `the ${index}th argument in ${className} constructor`;\n            metadata.set(index, opt);\n            Reflect.defineMetadata(INJECTED_ARGUMENTS, metadata, target);\n        } else {\n            console.warn('The decorater @Inject must used in properties or methods', target, name, index, options)\n        }\n    }\n}\n\n/**\n * Tag optional arguments or properties to inject.\n * @param options Injection options\n */\nexport function Optional(options?: Omit<InjectOptions, 'optional'> | RegisterType) {\n    return Inject(Object.assign({}, options, { optional: true }));\n}\n\n/**\n * Automatically inject properties or constructor arguments for the current class\n */\nexport function Injectable(options?: InjectionOptions) {\n    return function <T extends new (...args: any[]) => any>(ctor: T): any {\n        const metadata: Map<number, InjectOptions> = Reflect.getOwnMetadata(INJECTED_ARGUMENTS, ctor);\n        const result = class extends ctor {\n            constructor(...args: any[]) {\n                const paramtypes: Function[] = Reflect.getOwnMetadata(DESIGN_PARAM_TYPES, ctor) || [];\n                paramtypes.forEach((t, index) => {\n                    const meta = metadata && metadata.get(index);\n                    const type = meta && meta.type !== undefined ? meta.type : t;\n                    args[index] === undefined && (args[index] = Injector.get(type, meta));\n                });\n                super(...args);\n            }\n        };\n        Object.defineProperty(result, \"name\", { value: ctor.name });\n        Injector.registerClass(result, result, options);\n        return result;\n    }\n}\n","export const DESIGN_PARAM_TYPES = \"design:paramtypes\";\nexport const DESIGN_TYPE = \"design:type\";\nexport const DESIGN_RETURN_TYPE = \"design:returntype\";\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = require(\"reflect-metadata\");"],"sourceRoot":""}